%\nocite{Sakamoto1993}

この章では、UNIXと呼ばれるOS (オペレーティングシステム)の操作法について学ぶ。通常、Mac OS XやWindowsでは、マウスを使って画面を操作する。実は、Mac OS Xの内部ではDarwinと呼ばれるUNIX系のOSが動作しており、「ターミナル」アプリケーションを立ち上げることにより、UNIXの様々な機能に直接アクセスすることができる。また、ワークステーションやスーパーコンピュータなど、より大きな規模の計算を行うことのできる計算機も、ほぼ全てLinuxなどのUNIX系OSである。

UNIX系のOSの特徴としては、シンプル、柔軟かつオープンであり、ネットワークに強いことが挙げられる。シェルやスクリプト言語を組み合わせることにより、簡単なコマンドで複雑な処理を実現することができる。また、ネットワーク経由で使用することが前提となっており、実際に計算機がどこにあるかを意識することなしに、透過的に利用できる。UNIXを取得することにより、目の前のPCだけでなく世界中の計算機を利用することが可能となり、計算能力が一気に増えることになる。

\section{UNIX のコマンド}

この節での操作はすべて、ターミナル(「シェル」とも呼ぶ)内でコマンドを打ち込み、最後にリターンキーを押すことより実行する。確実に操作できるまで、繰り返し練習してほしい。下線を引いた部分がキーボードからの入力である。行頭の``\texttt {\promptn}''はプロンプトと呼ばれる。UNIXのシェルがユーザからのコマンド入力待ちの状態であることを示すものであり、コマンド入力時にタイプする必要はない。

\subsection{ファイルの操作}
\label{sec:unix:fileManagement}
この節では、ファイルを作ったり、消したりといった基本的な操作を紹介する。ファイルというのは計算機が情報を書き込むための一つの単位である。ファイルには名前を付けることができて、その名前を指定することでファイルを編集したり消したりできる。

%% %\newpage

\subsubsection{ファイルの基本操作}
ファイルをコピーするには{\tt cp}コマンド({\bf c}o{\bf p}yの略)を用いる。例えば、コマンドラインで
\begin{commandline2}
\prompt \underline{cp /usr/local/example/circle.c circle.c}
\end{commandline2} \noindent
を実行すると、{\tt /usr/local/example}という名前のディレクトリにあるファイル{\tt circle.c}が、カレントディレクトリにコピーされる。{\tt /usr/local/example/circle.c}の部分がコピー元に対応し、後の{\tt circle.c}がコピー先を意味する。コピー先がディレクトリの場合には、コピー先のディレクトリにコピー元と同じ名前のファイルが作られる。したがって、上の例は、カレントディレクトリを表す ``{\tt .}'' を用いて、
\begin{commandline2}
\prompt \underline{cp /usr/local/example/circle.c .}
\end{commandline2} \noindent
としても同じ結果となる。元とは異なる名前でコピーしたい場合には、
\begin{commandline2}
\prompt \underline{cp /usr/local/example/circle.c oval.c}
\end{commandline2} \noindent
などとする。同じ名前のファイルがすでに存在する場合には上書きされるので注意せよ。

ここで、{\tt ls}コマンド({\bf l}i{\bf s}tの略)を実行すると
\begin{commandline2}
\prompt \underline{ls}
\vspace*{-.8em} 
\begin{verbatim}
Desktop    circle.c
\end{verbatim}
\end{commandline2} \noindent
と表示され、正しくコピーされたことが分かる。このように、{\tt ls}コマンドを使うことで、どのようなファイルがあるのかを知ることができる。さらに、{\tt ls -l}を実行すると
\begin{commandline2}
\prompt \underline{ls -l}
\vspace*{-.8em} 
\begin{verbatim}
total 2
drwxr-xr-x  2 s001500 student      512 Apr 16 03:40 Desktop
-rw-r--r--  1 s001500 student      372 Apr 16 03:43 circle.c
\end{verbatim}
\end{commandline2} \noindent
のように、より詳細な情報\footnote{表示の1行目は、左端の {\tt d} が、そのファイルがディレクトリであることを示し、次の{\tt rwx}はファイルの所有者が読み取り可能({\tt r})、書き込み可能({\tt w})、実行可能({\tt x})であることを示している。(ディレクトリが読み取り可能であるとは、そのディレクトリにどのようなファイルが入っているかを{\bf ls}コマンドで調べられることをいい、ディレクトリが書き込み可能とは、そのディレクトリに新しくファイルやディレクトリを新しく作ったり、すでにあるファイルなどを消したりできることをいう。さらに、ディレクトリが実行可能であるとは、そのディレクトリ内部のファイルを操作できたり、そのディレクトリに移動するとか、そのディレクトリの名前をパスに含めることができることを意味する。) 次の{\tt r-x}は同じグループ(学生はすべて同じグループに属する)に所属する人が、読み取りと実行可能であることを示し、その次の{\tt r-x}はそのほかすべての人が読み取りと実行可能であることを示している。隣のカラムの{\tt s001500}は、そのファイルの所有者が{\tt s001500}であることを示し、次のカラムは所有グループを示している。次の{\tt 512}は、そのファイルの大きさが512 byteであることを示している。{\tt Apr 16 03:40}は、そのファイルに最後に変更を加えた日時を示す。そして最後がファイルの名前である。}を得ることができる。この{\tt -l}をオプション(あるいはコマンドラインオプション)と呼ぶ。{\tt ls}コマンドには他にも様々なオプションが用意されている。{\tt -F} オプションをつければ、ファイルの名前の後にファイルの種別を表す文字をつけてくれる。ディレクトリには {\tt /} が、実行可能ファイルには{\tt $ \ast$} がつく。{\tt -R} オプションをつければ、カレントディレクトリ以下のすべてのディレクトリの中身を見ることができる。また、{\tt -a} とすると、通常表示されない . (ピリオド)から始まるファイルも見ることができるようになる。

次にファイルの名前を変えてみよう。先の{\tt circle.c}を{\tt ring.c}に名前を変更するには、{\tt mv}コマンド({\bf m}o{\bf v}eの略)を使う。
\begin{commandline2}
\prompt \underline{mv circle.c ring.c}
\end{commandline2} \noindent
{\tt ls}コマンドで実際に名前が変更されたか確かめてみよう。

続いて{\tt rm}コマンド({\bf r}e{\bf m}oveの略)を用いてファイルを消してみよう。
\begin{commandline2}
\prompt \underline{rm ring.c}
\end{commandline2} \noindent
{\bf 一度消したファイルは二度と復旧できない}ので慎重に実行しなければならない。自信がないなら、
\begin{commandline2}
\prompt \underline{rm -i ring.c}
\end{commandline2} \noindent
のように{\tt -i}オプションをつけるとよい。ファイルごとに消してよいかどうかの確認をしてくれるので安心である。

さて、ここまでディレクトリという言葉が何度か出てきた。UNIXでは、ディレクトリという特殊なファイルを使って、たくさんのファイルをtree状に管理することができる。ディレクトリとは書類をまとめる書類箱だと思えばよいだろう。ときに大きな書類箱のなかに小さな書類箱が入っていることもあるわけで、ディレクトリの中にディレクトリがあってもいっこうに構わない。

ログインして最初にいるディレクトリのことをホームディレクトリと呼ぶ。今いるディレクトリ\footnote{カレントディレクトリ、あるいはワーキングディレクトリと呼ぶ。}がどこかを知るには、{\tt pwd}コマンド({\bf p}rint {\bf w}orking {\bf d}irectoryの略)を使う。{\tt /home/s001500} と表示されれば ルートディレクトリ\footnote{ルートディレクトリとは一番上のディレクトリのことであり、最初の{\tt /}がルートディレクトリを表す。}の下の {\tt home} というディレクトリの下の、{\tt s001500}というディレクトリにいるということが分かる。

試しに{\tt sample}という ディレクトリを作ってみよう\footnote{すでにあるディレクトリを消すには{\tt rmdir}コマンド({\bf r}e{\bf m}ove {\bf dir}ectoryの略)を使う。{\tt rmdir} でディレクトリを消すときはそのディレクトリの中にファイルやディレクトリが1つもない状態になっていなくてはならない。消したいディレクトリの中にファイルが残っているときは {\tt rm} コマンドを使い、ディレクトリが残っているときは {\tt rmdir} コマンドを使う。残っているファイルやディレクトリをいちいち消すのが面倒な場合は{\tt rm -r {\it directory}}とすれば、{\it directory}の中に何が残っていてもすべてきれいに消し去ってくれる。}。
\begin{commandline2}
\prompt \underline{mkdir sample}
\end{commandline2} \noindent
これで{\tt sample}というディレクトリが作成された。{\tt ls}コマンドで確かめてみよう。次に、今作ったディレクトリに移動してみよう。
\begin{commandline2}
\prompt \underline{cd sample}
\end{commandline2} \noindent
{\tt cd}は{\bf c}hange {\bf d}irectoryの略である。ここで、先ほどの {\tt cp}コマンドを使えば、このディレクトリにファイルをコピーすることができる。さらにこの中で\underline{{\tt mkdir chap4}}と打てば、{\tt sample}ディレクトリの下に{\tt chap4}ディレクトリが作成される。

では、元のディレクトリに戻るにはどうすればよいのだろうか? それには
\begin{commandline2}
\prompt \underline{cd ..}
\end{commandline2} \noindent
を実行する。{\tt cd}と{\tt ..}の間に空白があることに注意すること。

ツリー構造の中で、どのようにディレクトリやファイルを指定すればよいのだろうか。ディレクトリのツリーを図示すれば次のようになる。

\unitlength 1mm
\begin{picture}(100,85)(-30,-75)
\put(50,0){\fbox{/}}
\put(50,-5){\line(-2,-1){23}}\put(50,-5){\line(0,-1){13}}\put(50,-5){\line(2,-1){23}}
\put(25,-20){\fbox{home}}\put(47,-20){\fbox{usr}}\put(70,-20){\fbox{etc}}
\put(30,-24){\line(-2,-1){23}}\put(30,-24){\line(0,-1){12}}\put(30,-24){\line(2,-1){23}}
\put(0,-40){\fbox{hirano}}\put(25,-40){\fbox{s001500}  ...  }\put(50,-40){\fbox{s815xx} ....}
\put(28,-43){\line(-2,-1){23}}\put(28,-43){\line(0,-1){10}}\put(28,-43){\line(2,-1){23}}
\put(0,-56){\fbox{ftp}}\put(25,-55){\fbox{sample}}\put(50,-55){\fbox{tmp} ... }
\put(28,-58){\line(-2,-1){23}}\put(28,-58){\line(0,-1){10}}
\put(0,-72){\fbox{chap4}}\put(25,-72){\fbox{chap5} ... }
\end{picture}

\noindent このツリーの中の位置は、一番上の {\tt /} で表されるルートディレクトリから順にたどることより指定することができる。これを「絶対パス」と呼ぶ。あるいは、今いるディレクトリ(カレントディレクトリ)からの相対的な位置で指定する方法もある。これを「相対パス」と呼ぶ。例えば、ホームディレクトリの下の{\tt sample}の下の{\tt chap4}ディレクトリは、絶対的な指定では
\begin{tt}
/home/s001500/sample/chap4
\end{tt}
と書かれるが、カレントディレクトリがホームディレクトリの場合、相対的な指定では{\tt sample/chap4}と書かれる。そのディレクトリの中にあるファイルも {\tt /home/s001500/sample/chap4/circle.c}とか{\tt sample/chap4/circle.c}のように指定することができる。特に一つ上のディレクトリは``{\tt ..}''で、カレントディレクトリは``{\tt .}''であらわされる。つまり先ほどの{\tt sample/chap4/circle.c}は{\tt ./../s001500/sample/chap4/circle.c}と書いても同じものを指す。

これで、自由にディレクトリ間を移動することができるようになった。例えば、すでに使った{\tt ls}コマンドは、{\tt /usr/bin}あるいは{\tt /bin}ディレクトリに格納されている\footnote{\underline{\tt which ls}とすることで、{\tt ls}がどこにあるか調べることができる。}。\underline{\tt cd /usr/bin} として、そこに移動してから\underline{\tt ls}と打ってみよう。たくさんのファイルが置かれているが、{\tt ls} というファイルは見付かっただろうか\footnote{例えば、{\tt treasure.here}という名前のファイルを探したい場合、そのファイルがありそうなディレクトリよりも上のディレクトリに行って、\underline{\tt find . -name treasure.here -print}とする。{\tt find}の直後の {\tt .} (ピリオド)は「そのファイルがありそうなディレクトリより上のディレクトリのパス」を指定する。またファイル名があやふやな場合でも、\underline{\tt find . -name 'tre$\ast$.here' -print}のように$\ast$を任意の文字列として合致するファイルを表示してくれる。{\tt find}はとても多機能である。例えば\underline{\tt find . -name 'tre$\ast$.here' -exec cat \{\} $\backslash$;}のように、探し出したファイルに対してコマンドを実行することもできる。{\tt -exec} 以下の書式は コマンドの引数となるファイル名が\{\}となるように書き、最後に {\tt $\backslash$;} を加えればよい。{\tt -exec} の代わりに {\tt -ok} を使えばコマンドを実行する前に一々聞いて来るので {\tt rm}などを {\tt find} で実行したいときには安心である。\underline{\tt find\ .\ -ctime -1 -print}のように{\tt -ctime}で最終変更期日が1日前以内のものだけ表示させるようなことも可能である。{\tt -ctime}の引数を{\tt +1} にすると最終変更期日が1日以上前のものだけが表示される。}。

なお、\underline{{\tt cd}}とだけ打てば、いつでも自分のホームディレクトリに戻ってくることができる。ホームディレクトリは $\tilde{\ }$ とも表されるので \underline{{\tt cd $\tilde{\ }$}}としても同じである。

\subsubsection{ファイルの中を見る}

さて、肝心のファイルの中身を見るにはどうしたらよいのだろう。ファイルの中身を見るにはいくつかの方法がある。ファイルには大別して、中身を見ることができるテキストファイルと中身を見られないバイナリファイルがある。テキストファイルの中身は、{\tt cat}コマンドで見ることができる\footnote{バイナリのファイルの中身を覗くための{\tt od} ({\bf o}ctal {\bf d}ump)というコマンドもある。}。
\begin{commandline2}
\prompt \underline{cat circle.c}
\end{commandline2} \noindent
{\tt cat}は最も手軽にファイルの中身をのぞくことのできるコマンドである。中身が長すぎる場合、{\tt cat}では流れていってしまうが、
\begin{commandline2}
\prompt \underline{more circle.c}
\end{commandline2} \noindent
と打つことにより、ちょうどよい所で一旦止めてくれる。\fbox{\tt --More--(xx\%)} のような表示が左下に見えたら、\spc を叩いてみよう。次のページが表示されるはずである。\underline{\tt h}と打つと簡単なヘルプが見られる。\underline{\tt b}か\ctrl{B}で1ページ戻る。また\ret で1行進む。さらに、\underline{\tt /}の後に\underline{\tt 文字列}を打つことでファイル中の文字列を検索することができる。検索された文字列を含む行はウインドウの一番上に表示される。\underline{\tt n}と打てばもう一度同じ文字列を探してくれる。また、\underline{\tt 10d}のように数字を入れてから\underline{\tt d}を打てば、その数字分だけ進む。{\tt more}から抜けるには、\underline{\tt q}を入力する。

{\tt more}と似ているが、もう少し使い勝手のよい{\tt less}\label{sect:less}というコマンドもある。{\tt less}では上向きにスクロールすることができる。\underline{\tt j}で一行下に、\underline{\tt k}で一行上\footnote{編集用のソフト {\tt vi} のキー操作と同じ。}に進む。{\tt more}と同じく、スペースバー、\underline{\tt h}、\underline{\tt b}、\underline{\tt d}、\underline{\tt /}、\underline{\tt n}、\underline{\tt q}のようなコマンドも使える。更に \underline{\tt g}でファイルの先頭に、\underline{\tt G}でファイルの最後尾にジャンプすることができる\footnote{{\tt \underline{tail circle.c}}のようにすれば、ファイルの最後だけ見ることができる。また \underline{\tt tail -30}のように指定することで最後から30行目以降を見ることができる。}。

次に、たくさんあるファイルの中に特定の文字列が含まれているか調べてみよう。
\begin{commandline2}
\prompt \underline{grep main $\ast$.c}
\end{commandline2} \noindent
と入力してみよう。どの``{\tt .c}''で終るファイルに main という文字列が含まれているか一目瞭然である\footnote{さらに\texttt{\underline{grep -n printf $\ast$.c}}としてみると、各ファイルの何行目に printf という文字列があるのかが分かる。さらに、\texttt{\underline{grep -n -e $'.\ast$gram.$\ast'$ $\ast$.c}}で、.$\ast$のところに任意の文字列があてはまるすべての文字列について検索する。シングルクォーテーションで囲まなくてはいけない点に注意すること。}。

\subsubsection{ファイルの保護 (1)}
他の人に見られたくないファイルにはプロテクションをかけることができる。
\begin{commandline2}
\prompt \underline{chmod o-r circle.c}
\end{commandline2} \noindent
とすれば自分と、自分と同じグループに属する人以外はそのファイルを見ることができなくなる\footnote{{\tt o}は other の頭文字である。反対に他の人にも見えるようにするには \underline{\tt o-r} を\underline{\tt o+r} に変えて実行する。\underline{\tt chmod u=rwx,g+x,o-r circle.c}のように指定することもできる。そのほか {\tt g} (group) は 同じグループ、{\tt u} (user) は所有者、{\tt a} (all)はユーザーも含めた全員を表し、{\tt r} 、{\tt w} 、{\tt x} はそれぞれ、read, write, execute を表す。}。
\begin{commandline2}
\prompt \underline{chmod g-r circle.c}
\end{commandline2} \noindent
とすれば同じグループの人からも見られなくなる。同じ要領で
\begin{commandline2}
\prompt \underline{chmod o-rwx circle.c}
\end{commandline2} \noindent
とすれば他の人は {\tt circle.c} というファイルを読むことも書き込むことも実行することもできなくなり、
\begin{commandline2}
\prompt \underline{chmod go-rwx sample}
\end{commandline2} \noindent
とすれば自分以外のだれも {\tt sample} というディレクトリにアクセスできなくなる。
もし大切なファイルを間違いなどで変更したくない場合は、
\begin{commandline2}
\prompt \underline{chmod u-w circle.c}
\end{commandline2} \noindent
のようにすれば、自分自身の書き込みからもファイルを守ることができる\footnote{また変更したくなった場合は \underline{\tt chmod u+w circle.c} とすればよい。}。

\subsubsection{ファイルの保護(2)}
ファイルにプロテクションをかける方法がわかったところで、セキュリティの面から見たファイルの保護について説明しておこう。まず、特別な事情がないかぎり、ファイルに user 以外の書き込み許可を出してはならない。次に user 以外には読み取り許可(および実行許可)も出してはいけないディレクトリやファイルとしては、{\tt .Xauthority}、{\tt .ssh}などがある\footnote{``{\tt .}''で始まるファイルは隠しファイルである。ホームディレクトリで {\tt ls -a} とするとこれらのファイルを見ることができる。}。
%また読み取り許可をあまり出すべきではないファイルには、
%{\tt .mailrc}、
%{\tt .forward}、
%{\tt RMAIL}、
%{\tt バックアップファイル}
%などが考えられますので参考にしてください。

ファイルのアクセス許可について不安がある場合は、{\tt .bashrc}などのファイルに
\underline{\tt umask 077}の一行を入れておくとよい。こうしておくと、それ以後のログインで作られるファイルは、user 以外のアクセス許可がいっさいない状態で作られる。その後、許可を出してもよいと判断したファイルに限って、{\tt chmod}コマンドで許可を出すようにするとよいだろう。

\subsection{オンラインマニュアル}
ここまで様々なコマンドを説明してきたが、これらのコマンドのマニュアルは{\tt man}コマンドを使って、オンライン(計算機上)で見ることができる。まずはマニュアルのマニュアルを見てみよう。
\begin{commandline2}
\prompt \underline{man man}
\end{commandline2} \noindent
と打つと、{\tt Reformatting page.  Wait...} とでた後、画面が切り替わって、{\tt man}というコマンドのマニュアルが表示される。この画面を表示しているのは、すでに説明した{\tt \pager}\footnote{あるいは、環境変数 {\tt PAGER} を設定している場合にはそのページャーが立ち上がる。}なので、1ページ前に行ったり、スキップしたりするのも容易である。

ここまでに紹介して来た多くのコマンド\footnote{コマンドに限らずC言語用のライブラリ関数や設定ファイルの書式などもマニュアルに入っている。}がマニュアルに登録されている。
\begin{commandline2}
\prompt \underline{man {\it command}}
\end{commandline2} \noindent
のようにして、それぞれのコマンドの詳しい意味を調べてみよ。

正しいコマンド名が分かっているときはよいが、もし「〜のようなコマンドはないかな？」とか「たしかこんなコマンドがあったはず」と思ったときは、
\begin{commandline2}
\prompt \underline{man -k {\it keyword}}
\end{commandline2} \noindent
を使う。例えば、なにかディレクトリの操作に関するコマンドに関して調べるには、以下のようにすればよい。
\begin{commandline2}
\prompt \underline{man -k directory}
\vspace*{-.8em} 
\begin{verbatim}
...
mkdir (1)               - Makes a directory
mkdir (2)               - Creates a directory
mkdirhier (1X)          - makes a directory hierarchy
mkfontdir (1X)          - create fonts.dir file from directory of font files
mklost+found (8)        - Makes a lost\(plfound directory for fsck
mvdir (1)               - Moves (renames) a directory
pwd (1)                 - Displays the pathname of the current (working) directory
rename (2)              -  Renames a directory or a file within a file system
rmdir (1)               - Removes a directory
rmdir (2)               - Removes a directory file
...
\end{verbatim}
\end{commandline2} \noindent
\noindent 左端がマニュアルのタイトルである。右欄にある大雑把なコマンドの意味を参考に目的のものを探し出す。コマンド名の後に書いてある括弧の数字はマニュアルのセクション番号をあらわす。マニュアルは使う目的や内容に応じてセクションに分かれている。もし同じタイトルのマニュアルが二つのセクションに分かれて置かれている場合、それぞれは
\begin{commandline2}
\prompt \underline{man 2 rmdir}
\end{commandline2} \noindent
のように {\tt man}コマンドの後にセクション番号を書くことで指定することができる。
%\footnote{man path の通っていない所にマニュアルのファイル({\tt manual.1}としましょう)を見付けたら、\\
%{\tt \prompt \underline{nroff -man manual.1}}\\
%のようにすれば画面で見ることができます。
%}。

\subsection{プロセスの管理とトラブル時の対策}
\label{chap: recover}
この節では、ここではトラブル時の対策を含んだプロセスの管理について説明する。多少面倒な話なので読み飛ばしておいても構わない。

ターミナル上で何かを実行していて止まらなくなったときに最も有効なのは、\ctrl{c}である。\ctrl{c}は実行しているジョブを強制的に終了する。うまくいけばプロンプトが戻って来るはずである。

それでも止まらなかった場合には、\ctrl{z}を入力してみよう。\ctrl{z}はプロセスを一時的に停止させるだけなので、その後で終了させるか続行させるか、いずれかを選ぶ必要がある。もしプロンプトが戻って来たら、\underline{\tt jobs}と入力する。おおよそ
\begin{commandline2}
\prompt \underline{jobs}
\vspace*{-.8em} 
\begin{verbatim}
[1]    Running                  emacs local-guide.tex
[2]+   Suspended                a.out
\end{verbatim}
\end{commandline2} \noindent
のような出力が得られるはずである。悪さをしているのが、{\tt a.out} なら、行頭の[ ]のなかの数字である 2 に{\tt \%}をつけた{\tt \%2}を用いて
\begin{commandline2}
\prompt \underline{\tt kill \%2}
\end{commandline2} \noindent
として、ジョブを止める。もし、正常に走っているが単に時間がかかっているだけだとわかっているのであれば、
\begin{commandline2}
\prompt \underline{bg \%2}
\end{commandline2} \noindent
のように打ってバックグラウンドで実行してもよいだろう\footnote{最初からバックグラウンドで実行したいのであれば、コマンド実行時に最後に {\tt \&}をつければよい。例えば\underline{\tt a.out \&}のように実行する。一方バックグラウンドで走っているジョブをフォアグラウンドに戻すには、\underline{\tt fg \%2}などとする。}。

さて、\ctrl{c}でも\ctrl{z}でもジョブが終了できないときには、別のターミナルを開き、(必要に応じてSSHログインした後、) \underline{\tt ps x}と打つ。すると、
\begin{commandline2}
\prompt \underline{ps x}
\begin{verbatim}
  PID TT STAT  TIME COMMAND
27515 p0 IW    0:03 -bash
27767 p0 TW    0:00 emacs
28123 p3 R     0:24 ./a.out
28529 p3 R     0:00 ps
\end{verbatim}
\end{commandline2} \noindent
のように表示される。左からプロセスのID番号、制御端末、プロセスの状態を示す略号、現在までのCPU時間、そして実行中のコマンドが表示されている。このなかで悪さをしていそうなコマンドを探す。今の場合 {\tt ./a.out} が怪しいので、
\begin{commandline2}
\prompt \underline{kill 28123}
\end{commandline2} \noindent
として、そのプロセスを終了する。 28123 は {\tt ./a.out} のプロセスの ID 番号である。ちゃんとプロンプトが帰ってくれば一件落着である。それでもだめなときは、
\begin{commandline2}
\prompt \underline{kill -HUP 28123}
\end{commandline2} \noindent
としてみる。まだだめな場合は \underline{\tt -HUP} を \underline{\tt -QUIT }\footnote{\underline{\tt -QUIT} を使うとプロセス (この場合は {\tt a.out}) が実行中だったディレクトリに{\tt core} というとても大きなファイルができることがある。通常は必要ないので消してしまってかまわない。}にしてみよう。それでもうまくいかない場合は \underline{\tt -QUIT} を \underline{\tt -KILL} にするが、\underline{\tt -KILL} は最後の手段と考えて、無闇に使わないほうが無難である。

%% 例外的に、それでもだめな場合\footnote{その「例外」のひとつに、プロセス名が {\tt $<$defunct$>$}になっているプロセスがある。これは {\tt kill} コマンドではどうやっても終了させられないが、とくに害がないので気にしなくて構わない。気になるならば一度ログアウトすれば消えるはずである。}があります。しばらく待って
%% もう一度上の手順をやり直してもだめなときは、
%% ルートウインドウを
%% マウスの\destroymenu ボタンでドラッグして \killmenu の所で離します。
%% するとマウスカーソルがドクロマークに変わりますから、そのドクロマークで、殺したいウインドウを
%% クリックしてください。

%% さらに上記の方法でも、正しいと思われる状態に復帰しない場合、閉じられるウインドウは閉じ、
%% 閉じられそうもないウインドウは開けたままで、ルートウインドウでマウスの右ボタンをドラッグし、
%% {\bf Exit X-Window} を選びます。こうすることで多くの実行中のプロセスは終了されるはずです。
%% 少し待って、ログインパネルが戻って来たら、もう一度ログインして、{\tt who} や {\tt ps}などのコマンドで、
%% 前のプロセスが残っていないかチェックして見てください。残っていた場合は、{\tt kill}コマンドで
%% そのプロセスを殺します。

%% いろいろやっても、どうにもしようがなくなった
%% \footnote{深刻に悩むことはありません。}
%% なら、\admin に連絡するか、
%% 最後の手段、iMac端末の電源を一旦切って入れる
%% \footnote{フロントパネルにあるのだけではなく、後ろにあるものをためしてもよいです。}
%% という作業をして、端末をリセットしてください。しかし、その後もう一度ログインして、
%% {\tt who}あるいは{\tt ps}を用いていらないプロセスが残っていないか確かめることを忘れないで下さい。

%% また、プロセス管理に関連することですが、
%% 自分が以前に発行したコマンドが、正常終了しないで
%% いつまでも残ってしまうことがあります。
%% \underline{\tt ps x} と打ってそのようなプロセスを発見したときは、
%% やはり同じように {\tt kill} コマンドでプロセスを終了させてください。

\subsection{パイプとリダイレクション}

UNIX の設計思想の一つに小さなツールを組み合わせるということがある。いまから紹介するのがその小さなツールを組み合わせるためのコマンドの書き方である。

\subsubsection{パイプ}
例えば、{\tt ps} コマンドの出力の中から、emacs のプロセス ID を調べようとするとき、{\tt ps}コマンドと文字列を探し出す{\tt grep}コマンドを組み合わせて、
\begin{commandline2}
\prompt \underline{ps $|$ grep emacs}
\end{commandline2} \noindent
のように実行する。``{\tt $|$}''はパイプと呼ばれ、パイプの左側のコマンドが出力するデータをパイプの後ろのコマンドの入力に繋いでくれる。ここで使えるのは、画面に結果を書き出すコマンドとキーボードから入力を読み込むコマンド\footnote{{\tt grep} のマニュアルを見れば分かるが、{\tt grep} は入力ファイルが指定されずに起動された場合は、標準入力(ふつうはキーボード)を探すと書いてある。}の組み合わせだけであることに注意せよ。

パイプを使えば、{\tt ls}などの出力で流れて行ってしまうものを、
\begin{commandline2}
\prompt \underline{ls -laF $|$ more}
\end{commandline2} \noindent
のようにして、一時的なファイルを作る手間なしに、{\tt more}を使ってゆっくり眺めることができる。

\subsubsection{リダイレクション}

次は、リダイレクションである。リダイレクションとは、通常画面に書かれる内容を、かわってファイルに書き出したり、通常キーボードから読まれる入力をファイルから読み込むようにする機能である。これを用いれば、コマンドの実行結果をファイルに保存したりすることも可能である。例えば、
\begin{commandline2}
\prompt \underline{ls -laF $>$ ls.dat}
\end{commandline2} \noindent
のようにすれば、{\tt ls -laF}の結果が {\tt ls.dat} に書き出される。また、Cのプログラムでの計算結果をいったんファイルに落とし、{\tt gnuplot} (\ref{sec:unix:gnuplot}節)で図にプロットするというといった作業も行うことができる。

\subsection{コマンドヒストリとコマンドライン補完}

コマンドヒストリとコマンドライン補完は、なれてしまうと手放せなくなる機能である。コマンドヒストリとは、一度実行したコマンドを呼び出す機能のことである。これを使えば、同じコマンドを実行するたびに最初から打つ手間が省ける。また、以前実行したコマンドをちょっと変えて実行するということも簡単にできる。以前に実行したコマンドを呼び出すためには、プロンプトの所で\ctrl{p}を押すか、キーボードの上矢印を押す。プロンプトの後にコマンドが表示されるはずである。ここで\ret すれば、そのまま実行される。あるいは\ctrl{b}(左矢印)や\ctrl{f}(右矢印)\footnote{これらの矢印のついたキーのことをカーソルキーと呼ぶ。}や \BS を使って編集してから実行することもできる。\ctrl{n}(下矢印)を押せば逆にヒストリを戻ってくることができる。また、
\begin{commandline2}
\prompt \underline{{\tt !{\it string}}}
\end{commandline2} \noindent
とすれば、{\it string}\footnote{{\it string}は例である。もちろんどのような文字列でも構わない。}から始まる一番最近のコマンドを実行してくれる。さらに \ctrl{r}に続けて過去に打ったコマンドを頭から入力していくと、コマンドヒストリの中から逐次候補が表示される(インクリメンタルサーチ)。大昔に打ったコマンドを捜し出すのに便利である\footnote{実際のところ、\underline{\tt !{\it string}}では、そのままコマンドが実行されてしまうので、\ctrl{r}の方が便利である。}。
\begin{commandline2}
\prompt \underline{history}
\end{commandline2} \noindent
と打つと、これまでのコマンド一覧が表示される。その数は標準では 500 になっている\footnote{初期設定ファイルの {\tt .bashrc} に{\tt export HISTSIZE=1000} と書いておくと  最大 1000 個までの過去のコマンド履歴が記録される。また、次にログインしたときにも前回ログインした時のヒストリが残されている。}。

次は、コマンドライン補完である。例えば
\begin{commandline2}
\prompt \underline{ls -aF}
\begin{verbatim}
./          excellent-bitmaps/  work/
../         save/
archive/    TeX/
emacs.doc   temp.out$\ast$
\end{verbatim}
\end{commandline2} \noindent
のような状況で次のようなコマンドを打ちたいとする。
\begin{commandline2}
\prompt \underline{\tt chmod o-rx excellent-bitmaps}
\end{commandline2} \noindent
をいちいち最初から最後まで打っていたのでは、面倒である。そこでまず、
\begin{commandline2}
\prompt \underline{chm}
\end{commandline2} \noindent
まで打った所で、左の方にある\ovalbox{Tab}キーを押してみよう。すると、
\begin{commandline2}
\prompt \underline{chm}od\ \cursor
\end{commandline2} \noindent
のように変わる。つまり、自動的にコマンドの一部を補完してくれるのである。さらにこの機能はコマンドだけではなく、ファイルやディレクトリの名前、ユーザー名にも使える。さっきの例では
\begin{commandline2}
\prompt \underline{chm}od \underline{o-rx ex}
\end{commandline2} \noindent
まで打った時点で、\ovalbox{Tab}\footnote{\ovalbox{Tab}でなく、\ctrl{d}を押せば、補完可能な候補の一覧が表示される。}を押せば、自動的に
\begin{commandline2}
\prompt \underline{\tt chm}od \underline{o-rx ex}cellent-bitmaps
\end{commandline2} \noindent
と補完される。%% なぜ、\\
%% \begin{tt}
%% \prompt \underline{\tt chm}od \underline{o-rx e}\\
%% \end{tt}
%% の時点ではないのかといいますと、このディレクトリには、{\tt emacs.doc} というファイルもあるので、
%% {\tt e}から始まるという条件では、一意にファイルを指定できないからです。\underline{\tt ex} まで打ってしまえば、
%% もうほかに {\tt ex} で始まるファイルはありませんから一意に決まります。
これらの機能を利用すれば、これまで以上に効率よくUNIXとコミュニケーションを取れるはずである。

\subsection{その他有用なコマンド}
他によく使うコマンドを紹介しておこう。
\begin{itemize}
  \itemf{who}

  いま使っている計算機にだれがログインしているかを表示する。
  
  \itemf{clear}

  ターミナル画面で、画面をクリアする。

  \itemf{date}

  現在の日付と時間を表示する。

  \itemf{cal}

  今月のカレンダーを表示する。\underline{\tt cal \nendo}とすれば今年のカレンダーを表示する。
  
  \itemf{du}

  あるディレクトリ以下について、ディレクトリごとにファイルの大きさの総和を取って表示する。\underline{\tt du -s .}として使用することで、カレントディレクトリ以下のファイルの大きさの総和を表示する。

  \itemf{tar}\label{sect: tar}
  
  ファイルをまとめて一つにまとめる。{\bf t}ape {\bf ar}chiverの略である。ファイルを転送したり、バックアップを取るときに利用する。
  \begin{commandline2}
    \prompt \underline{tar cvf ../archive.tar .}
  \end{commandline2} \noindent
  のように使うと、{\tt ../archive.tar} というファイル\footnote{ファイル名の最後に {\tt .tar} を付ける習慣にしておくと、あとで混乱が少なくなる。}にカレントディレクトリ以下のすべてのファイルのバックアップが取られる。{\tt .} の代わりに {\tt $\ast$.c} を使えば カレントディレクトリの {\tt .c} で終るファイルがまとめられる。また、{\tt .} の部分にディレクトリを指定すれば、そのディレクトリ以下のファイルすべてのバックアップを取ることができる。反対に展開するときは、
  \begin{commandline2}
    \prompt \underline{tar xvf archive.tar}
  \end{commandline2} \noindent
  のようにする。
\item {\tt gzip}\\
ファイルを圧縮してサイズを小さくする。
\begin{commandline2}
\prompt \underline{gzip {\it origin}}
\end{commandline2} \noindent
のように実行すると、{\it origin}というファイルが消えて、{\it origin}{\tt .gz}というファイル\footnote{ファイルの最後に {\tt .gz} が付く。逆にもし、ファイルの最後が {\tt .gz} になっているファイルがあれば、それは {\tt gzip} で圧縮されていると思ってよい。}が作成される。解凍\footnote{圧縮を元に戻すことである。}するには、
\begin{commandline2}
\prompt \underline{gzip -d {\it oringine}.gz}
\end{commandline2} \noindent
あるいは
\begin{commandline2}
\prompt \underline{gunzip {\it origin}.gz}
\end{commandline2} \noindent
のように実行する\footnote{{\tt tar} + {\tt gzip} ファイル(ファイル名の末尾が{\tt .tar.gz}になっているか、{\tt .tgz} になっている場合が多い)を解凍・展開するときには、{\tt \underline{gzip -cd archive.tar.gz $|$ tar xvf -}}のようにパイプをうまく使うと、中間ファイルの {\tt archive.tar} を生成せずにいきなりディレクトリに展開してくれる。また、\underline{\tt tar zxvf archive.tar.gz}でも同じ結果となる。逆に、\underline{\tt tar zcvf archive.tar.gz .}で、圧縮されたアーカイブを直接作成することができる。}。しばしば{\tt tar}と組み合わせて使われる。
%% \itemf{compress (uncompress)}\\
%% {\bf gzip} と同様にファイルを圧縮します。こちらは、
%% \\
%% \begin{tt}
%% \prompt \underline{compress {\it origin}}\\
%% \end{tt}
%% とすれば、{\it origin} は消えて、{\it origin}{\tt .Z}
%% \footnote{ファイルの最後が {\tt .Z} で終わります。
%% ほかにもファイルの最後が {\tt .z} で終わるファイルを見かけるかもしれません。
%% これは {\bf pack} というコマンドで圧縮されていて、{\bf unpack}というコマンドで解凍します。{\bf pack} は圧縮効率が
%% あまりよくないので、圧縮のために自分で使う必要はないでしょう。}
%% というファイルができます。解凍するには、
%% \\
%% \begin{tt}
%% \prompt \underline{uncompress {\it origin}}\\
%% \end{tt}
%% と打ちます。こちらも、{\bf tar}と一緒によく使われます
%% \footnote{{\bf tar}と一緒に使った場合、\underline{\tt zcat archive.tar.Z $|$ tar xvf -}のようにして、中間ファイルの
%% {\tt archive.tar} を生成しないようにすることもあります。}$^{,}$\footnote{
%% {\bf compress}が UNIX の標準ソフトウェアであるのに対し、
%% {\bf gzip} はフリーソフトウェアであるため、場合によっては
%% {\bf gzip}が使えないこともあります。
%% }
%% 。

%% \itemf{uuencode}\\
%% このコマンドは、バイナリ形式のファイルを送る際、一旦テキスト形式に変換する
%% ためのものです。これを使えばバイナリファイルを 電子メールで送ることができるようになります。
%% 使い方は、encode時が
%% \\
%% \begin{tt}
%% \prompt \underline{uuencode {\it source destination} $>$ {\it output.uu}}\\
%% \end{tt}
%% のようにします。まず encode したいファイルが {\it source}で、decode したときに
%% \footnote{つまりメール等の受け取り人が decode したときに}
%% 、できるファイルの名前が{\it destination}
%% \footnote{{\it source}と{\it destination} は同じでも構いません。}
%% です。encode された内容は{\it output.uu} に書かれますのでこれを電子メールかなにかで、
%% 相手先に送り届ければ OK です。反対に decode したいときには
%% \\
%% \begin{tt}
%% \prompt \underline{uudecode {\it output.uu}}\\
%% \end{tt}
%% のようにします。するとこの例では {\it destination}というファイルが生成されます。この{\it destination}というファイルの
%% 内容は、送り元のほうにあった {\it source}と同じものです。

%% \itemf{quota}\\
%% ハードディスクの使用量には最大値が決められています。
%% {\bf quota} を
%% \\
%% \begin{tt}
%% \prompt \underline{quota -v}\\
%% \end{tt}
%% のように使うことによりその最大値と自分の現在の使用量を知ることができます。
%% 最大値を越えてしまうとファイルが新しく作れなくなってしまいます
%% \footnote{
%% 最大値を越えた状態でほうっておくと、
%% (アカウントがなくなってしまうわけではありませんが)
%% iMac 端末の利用が一時的にできなくなってしまうことがあります。}
%% ので {\bf gzip} や {\bf compress} を利用したり、不要なファイル
%% \footnote{
%% とくに {\tt core} ファイルは積極的に使う理由がないかぎり消してしまいましょう。
%% \ifx\shellname\shellbash
%%   また {\tt .bashrc} に\\
%%   \begin{tt}
%%   \underline{ulimit -c 0}\\
%%   \end{tt}
%% \else
%%   また {\tt .cshrc} に\\
%%   \begin{tt}
%%   \underline{limit coredumpsize 0}\\
%%   \end{tt}
%% \fi
%% という行を入れておくと {\tt core} ファイルができなくなります。}
%% を消したりして対応してください。

\itemf{ln}

ファイルのリンク\footnote{コンパイラのところで登場する「リンク」という言葉とは関係ない。}を作成する。
\begin{commandline2}
\prompt \underline{ln {\it filename} {\it linkname}}
\end{commandline2} \noindent
のように実行する\footnote{{\tt cp} と同じ順序で引数を指定する。}と{\it filename} というファイルは{\it linkname}という名前でもアクセスできるようになる。これをリンク、とくにこの場合はハードリンクと呼ぶ。ハードリンクがコピーと違うのは、{\it filename} の内容を変更した場合、自動的に {\it linkname}の内容も変更される\footnote{ハードリンクを作ると {\it filename} と {\it linkname} の区別はなくなり、両者は対等の関係になる。}ことと、ディスクの使用量がハードリンクを作っても(ほとんど)かわらないことである。また誤って {\it filename} か {\it linkname} のどちらかを消してしまっても一方は残っているので、バックアップの役にも立つ。しかし、ハードリンクは「自分のホームディレクトリ内」のように限られた空間\footnote{同一パーティション内のこと。}内でしか利用できない。

ハードリンクに対して、シンボリックリンクというものもある。シンボリックリンクは
\begin{commandline2}
\prompt \underline{ln -s {\it filename} {\it linkname}}
\end{commandline2} \noindent
のようにして作成する\footnote{シンボリックリンクを作ることを、「リンクを張る」といういいかたをすることがある。}。シンボリックリンクもハードリンクと同じく、{\it linkname} によって {\it filename} にアクセスすることが可能になる。しかし、 {\it filename} を消したり、{\it filename} の名前を変更したりすると、もはや {\it linkname}でファイルにアクセスすることはできなくなってしまう。シンボリックリンクは、同一パーティション内にないファイルに対しても作成することができる。

\itemf{time}

コマンドの実行時間を計測する。例えば
\begin{commandline2}
\prompt \underline{time gzip {\it origin}}
\end{commandline2} \noindent
のように、コマンドの前に{\tt time}コマンドをつけて実行すると、コマンドの実行にかかった実時間(real), ユーザCPU時間(user)、システムCPU時間(sys)が表示される。

\end{itemize}

\section{リモートログインとファイル転送}
\label{sec:ssh}

ある計算機から別の計算機へネットワーク経由でログインし作業するには、{\tt ssh} ({\bf s}ecure {\bf sh}ellの略)あるいは{\tt slogin}コマンドを利用する\footnote{同様の機能を持つものに{\tt telnet}、{\tt rlogin}というコマンドがあるが、パスワードが平文でネットワーク上を流れるなど、セキュリティー上の問題があるので、今日では使われない。}。例えば、ホスト名が remote.phys.s.u-tokyo.ac.jp というマシンにログインしたい場合、
\begin{commandline2}
\prompt \underline{ssh -X remote.phys.s.u-tokyo.ac.jp}
\end{commandline2} \noindent
あるいは
\begin{commandline2}
\prompt \underline{slogin -X remote.phys.s.u-tokyo.ac.jp}
\end{commandline2} \noindent
と入力する\footnote{{\tt -X}オプションはリモートマシン上で実行するEmacs、gnuplot、evinceなどのウィンドウを手元のマシンの画面で開くためのもの(X11 forwarding)である。}。現在ログインしているマシン(ログイン元)と接続しようとしているマシン(ログイン先)のアカウント名が異なるときは、
\begin{commandline2}
\prompt \underline{ssh -X remote.phys.s.u-tokyo.ac.jp -l {\it username}}
\end{commandline2} \noindent
あるいは
\begin{commandline2}
\prompt \underline{slogin -X {\it username}@remote.phys.s.u-tokyo.ac.jp}
\end{commandline2} \noindent
とする。{\it username}はログイン先のアカウント名である。次にパスワードを入力すると、remote.phys.s.u-tokyo.ac.jp に接続され、プロンプトが表示される。ただし、初めて接続するマシンの場合、次のようなメッセージが
出力される。
\begin{quote}
\begin{verbatim}
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)?
\end{verbatim}
\end{quote}
ここで、{\tt yes} と答えると、パスワードの入力に進むことができる。ログイン後、入力する命令は、すべてリモートホスト上で実行される。最後に 
\begin{commandline2}
\prompt \underline{exit}
\end{commandline2} \noindent
と入力すると、接続が解除され、元のマシンのプロンプトに戻る。

ある計算機から別の計算機にファイルをコピーしたい場合には、{\tt scp} ({\bf s}ecure {\bf c}o{\bf p}yの略)コマンドを用いる。手元のマシンからリモートのマシン(例: remote.phys.s.u-tokyo.ac.jp)へファイル(report.pdf)を送る場合は、
\begin{commandline2}
\prompt \underline{scp report.pdf {\it username}@remote.phys.s.u-tokyo.ac.jp:\~{} }
\end{commandline2} \noindent
とする。最後の{\tt ~}(チルダ)はリモートマシンのホームディレクトリ({\tt /home/{\it username}})を表す。コピー元のファイル名や、コピー先のディレクトリ名は適宜変更すること。
また、.pdfという拡張子のつくファイルをすべて送りたい場合は、
\begin{commandline2}
\prompt \underline{scp *.pdf {\it username}@remote.phys.s.u-tokyo.ac.jp:\~{} }
\end{commandline2} \noindent
とすればよい。report というディレクトリを送りたい場合は、
\begin{commandline2}
\prompt \underline{scp -r report {\it username}@remote.phys.s.u-tokyo.ac.jp:\~{}}
\end{commandline2} \noindent
とする。逆に、リモートマシンのファイルをこちらへ取ってくる場合は、
\begin{commandline2}
\prompt \underline{scp {\it username}@remote.phys.s.u-tokyo.ac.jp:\~{}/report.pdf .}
\end{commandline2} \noindent
などとする。最後の{\tt .} (ドット)はカレントディレクトリを表す。

%% %\newpage
%% %\subsection{Emacs を使う}
\section{Emacs を使う}

C言語のプログラムや \LaTeX のソースコードなど、テキスト形式のファイルの編集には、エディタと呼ばれるソフトを用いる。UNIXで代表的なものとしては、viやEmacsがある。本節では Emacs の使い方を紹介しよう。

まず、Emacs を立ち上げるには
\begin{commandline2}
\prompt \underline{emacs}
\end{commandline2} \noindent
と入力すればよい。あるいは、
\begin{commandline2}
\prompt \underline{emacs \&}
\end{commandline2} \noindent
としておけば、Emacs を別ウィンドウで立ち上げた後、元のターミナル内で別の作業を続けることができる。
%\subsubsection{チュートリアル}
\subsection{チュートリアル}
Emacs のコマンドの多くは
%\footnote{実際は普通の文字も self-insert-command だそうですが...
%GNU Emacs Zenith Guide for Programmers 亀井信義 技術評論社 より}
\ctrl{なんとか} と \esc{なんとか}\footnote{\ovalbox{Esc} は \ovalbox{Control} と違い、一旦 \ovalbox{Esc} を押して離した後に、他のキーを押す。}にキー定義されている。

Emacsのチュートリアル自体も、
%本当は {\bf help-with-tutorial-for-mule}というコマンドなのですが、
%いちいちこの長いコマンドを打たなくて済むように、
\ctrl{h} \ovalbox{T} に割り当てられている。\ctrl{h} \ovalbox{T} を押すときは、まず\ctrl{h}を押してコントロールキーを離してから T を押す。ここで T は大文字なので \ovalbox{Shift} キーと同時に押すことを忘れないこと。また、本来のコマンド名 \esc{x} {\tt help-with-tutorial} と打ってももちろんかまわない。以下、キーバインドの後にカッコ中に太字で書いてあるのがコマンドで、すべてのコマンドは \esc{x} \underline{コマンド名} と打つことでも、実行が可能である。
このチュートリアルは基本的な事柄を網羅しているので、載っているキー定義を覚えてしまえば相当 Emacs が使いやすくなるはずである。

Emacs を使っていて何か困ったと思ったときは、まず \ctrl{g} ({\bf keyboard-quit})
を押してみよう。それでもだめなら \ctrl{x} \ctrl{c} ({\bf save-buffers-kill-emacs})で Emacs から抜け出ればよい。

%\subsubsection{編集作業}
\subsection{編集作業}
それでは Emacs の中から、何かファイルを編集してみよう。Emacs が立ち上がった状態からファイルを編集し始めるには、\ctrl{x} \ctrl{f} ({\bf find-file})
%% \footnote{チュートリアルを見ればわかりますが、\ctrl{x} \ctrl{f}の代わりに、
%% \esc{x} {\tt find-file} と打ってもよいです。またEmacs のウインドウの上の方にある {\bf File}の項目から Open File を
%% マウスで選んでも構いません。}
とする。
\begin{commandline2}
Find file: \til /
\end{commandline2} \noindent
と聞いてくるので、既存のファイルを編集したいのならそのファイル名を、もし新たにファイルを作って編集を始めたいのならそのファイル名を入力する\footnote{ここで読み込まれたファイルはバッファと呼ばれる一時的に確保される記憶領域に置かれる。編集の操作はすべて、バッファに対して行われるので、ファイルに書き出さないと編集の結果は残らない。}。ここでは、ためしに {\tt trial.c}というファイルを編集してみよう。

普通のキーは打てばそのままキートップに書いてある文字が挿入される。何か間違えた時には \BS で消す。カーソルキーを使ってカーソルを移動することも可能である。カーソルキーを使わないで、\ctrl{p} ({\bf previous-line})、\ctrl{n} ({\bf next-line})、
\ctrl{f} ({\bf forward-char})、\ctrl{b} ({\bf backward-char})でも構わない。

Emacs はファイルの名前から判断して、これから編集するのが C のプログラムだと認識する。
Emacs のウインドウの下にあるモードライン(反転表示されている一行のこと)にCの文字が見えるはずである。

Cのプログラムは、通常次のようにブロックをインデントする。
\begin{quote}
\begin{verbatim}
int main() {
  return 0;
}
\end{verbatim}
\end{quote}
インデントを行うのに、いちいちその数だけスペースを打つのは面倒である。Emacs は C のファイルを編集していると認識すると、\ovalbox{Tab}を打つことで適当な場所まで
インデントを行ってくれる。

何か文章やプログラムをEmacs上で書いたとしよう。編集したファイルを保存するには、\ctrl{x} \ctrl{s} ({\bf save-buffer})を使う。
\begin{commandline2}
Wrote /home/s001500/trial.c
\end{commandline2} \noindent
のような表示が Emacsのミニバッファに出るはずである。Emacs の隣のターミナル画面で {\tt ls} コマンドを実行して {\tt trial.c} というファイルが新たに生成されていることを確かめよう。さらに、{\tt cat} とか {\tt more}のようなコマンドでファイルの中身を確かめてみるのもよい。

さて、Emacs での作業も終ったので、Emacs から抜け出すことにしよう。Emacs から抜けるには、\ctrl{x} \ctrl{c} ({\bf save-buffers-kill-emacs})とする。

%\subsubsection{Emacs の様々なコマンド}
\subsection{Emacs の様々なコマンド}
Emacs には実に様々なコマンドがあるが、その中でも使用頻度の高いコマンドをまとめておく。コマンドは、\esc{x}\ \underline{コマンド}と打つことでも実行できる。

\noindent {
\renewcommand{\baselinestretch}{0.8}
\begin{footnotesize}
\hspace*{-1.0cm}
\begin{tabular}{lll}
キー定義 & コマンド & 動作\\
\hline
\ctrl{x} \ctrl{f} & find-file &新たにバッファを作り、そのバッファに読み込むファイルの名前を尋ねて読み込む。\\
\ctrl{x} \ovalbox{i} & insert-file & 現在のカーソルの位置に指定したファイルを挿入する。\\
\ctrl{x} \ctrl{c} & save-buffers-kill-emacs &Emacs を終了する。保存されていないバッファは保存するかどうか尋ねてくる。\\
\ctrl{x} \ctrl{s} & save-buffer &バッファの内容をファイルに書き出す。\\
\ctrl{x} \ctrl{w} & write-file &バッファの内容を書き出すファイルの名前を尋ねてから書き出す。\\
\ctrl{g} & keyboard-quit &コマンドの入力を中断する。\\
\ctrl{v} & scroll-up &画面一枚分上にスクロールする。\\
\esc{v}  & scroll-down &画面一枚分下にスクロールする。\\
\ctrl{s} & isearch-forward &下向きに文字列を検索する。検索モードから抜けるには、\ovalbox{Esc} を打つ。\\
\ctrl{r} & isearch-backward &上向きに文字列を検索する。検索モードから抜けるには、\ovalbox{Esc} を打つ。\\
\esc{\%} & query-replace & 文字列の置換を行う。スペースで実行、``n''で不実行。\\
& & ! で合致するすべてを置換する。\\
\ctrl{k} & kill-line & 現在いる行のカーソルより後ろを削除する。\\
\ctrl{スペース} & set-mark-command &マークを設定する。\\
\ctrl{w} & kill-region &マークから現在のカーソルの位置までを削除する。\\
\ctrl{y} & yank &カーソルの位置に削除した内容を戻す。\\
\ctrl{x} \ovalbox{u}& advertised-undo &アンドゥ、直前の操作を取り消す。\\
\esc{$<$} & beginning-of-buffer &文章の始めに飛ぶ。\\
\esc{$>$} & end-of-buffer & 文章の終りに飛ぶ。\\
\ctrl{x} \ovalbox{2} & split-window-vertically &ウインドウを二つに分割する。\\
\ctrl{x} \ovalbox{1} & delete-other-windows &今カーソルのいるウインドウを残し、他のウインドウを消す。\\
\ctrl{x} \ovalbox{o} & other-window & ウインドウが分割されているとき、違うウインドウに飛ぶ。\\
\ctrl{x} \ovalbox{5}\ovalbox{2} & make-frame & 新たにフレームを作る。\\
\ctrl{x} \ovalbox{5}\ovalbox{0} & delete-frame & 現在のフレームを消す。\\
\ctrl{x} \ovalbox{b} & switch-to-buffer & 他のバッファにスウィッチする。\\
\ctrl{x} \ctrl{b} & list-buffers &現在のバッファ一覧を出す。\\
\ctrl{l} & recenter &ウインドウをリフレッシュし、カーソル行をウインドウ中央に移動する。\\
\ctrl{$\backslash$} & toggle-egg-mode &かな変換モードを on/off する。\\
\ctrl{x} \ovalbox{(} & start-kbd-macro &キーボードマクロの定義を開始する。\\
\ctrl{x} \ovalbox{)} & end-kbd-macro &キーボードマクロの定義を終了する。\\
\ctrl{x} \ovalbox{e} & call-last-kbd-macro &一番最近定義したキーボードマクロを実行する。\\
\end{tabular}
\end{footnotesize} \\
\noindent
ある領域を削除、移動、コピーしたいときには領域の先端でマークし、領域の終端までカーソルを移動した後、\ctrl{w}を押して領域を削除する。移動したいときには、さらに移動先までカーソルを持って行き、そこで\ctrl{y}を押す。コピーしたいときには、削除した直後に\ctrl{y}を押して復旧し、さらにコピー先までカーソルを持って行って、\ctrl{y}を押してコピーする。つまり一旦\ctrl{w}でためておいてから\footnote{実は\esc{w}だと削除しないでためるだけなので、こちらの方が楽である。}、\ctrl{y}であちこちにコピーする。また、\ctrl{k}を連続して使って消した場合も、\ctrl{y}でまとめてペーストすることができる。そのほか便利な機能としては、\esc{x} {\tt goto-line}で指定行に飛ぶ等が挙げられる。

%% Emacs他にもたくさんの機能がありますが、たくさんありすぎて紹介できません。
%% Emacs について詳しく知りたい人は、GNU Emacs ソフトバンクや
%% GNU Emacs Zenith Guide for Programmers 亀井信義 技術評論社 を参考にしてください。

%\subsubsection{日本語変換}
%% \subsection{日本語変換}
%% \label{sect: Japa}
%% かな漢字変換を開始するには、\ctrl{$\backslash$}を入力します。Emacs のモードラインの左の端に [あ] と出たと
%% 思います。もう一度 \ctrl{$\backslash$} を入力すると、元の無変換のモードに戻ります。

%% さて、漢字変換モードにはいったら、何か日本語を打ってみましょう。試しに「お魚くわえたドラ猫」と
%% 打ってみましょう。
%% \begin{verbatim}
%% osakanakuwaetadoraneko
%% \end{verbatim}
%% とうつと、
%% \begin{verbatim}
%% |おさかなくわえたどらねこ|
%% \end{verbatim}
%% のように表示されたと思います。そこで \spc を一回叩くと、何かメッセージが流れた後、Emacs のミニバッファで
%% \begin{verbatim}
%% 頻度ファイルxxxが無いよ。作る?(y or n)
%% \end{verbatim}
%% と聞いて来ます。その後何度か同じような質問を受けますがすべて \underline{\tt y} と答えてゆきます(11 回答えることになると思います。)。すると、
%% \begin{verbatim}
%% |お-魚 加え 他-度 羅 寝 子|
%% \end{verbatim}
%% のような変換をしたと思います。両端の``$|$''はこの棒の間が変換中であることを示しています。

%% ``お-魚''の部分はOKなので、\ctrl{f}でカーソルを``加''まで持って行きます。``くわえた''で一言なので、
%% 文節を広げるために \ctrl{o}をうちます。すると
%% \begin{verbatim}
%% |お-魚 加えた 度 羅 寝 子|
%% \end{verbatim}
%% のように変わったと思います。``加えた''では駄目なので \spc を二回叩いて、``くわえた''と平仮名に直します。
%% そこまで来たら、\ctrl{f} でまた一歩前進して、``度''のところまでカーソルを持って来て、
%% また文節を広げるために \ctrl{o} を入力します。すると、
%% \begin{verbatim}
%% |お-魚 くわえた ドラ 猫|
%% \end{verbatim}
%% のように変わって目指す文字列になったので、\ret を打って変換を確定します。
%% これでやっと「お魚くわえたドラ猫」とうつことができました。今は文節を広げる例しか出て来ませんでしたが、
%% その反対に文節の長さを縮めるときには \ctrl{i} を使います。

%% \spc で変換の次候補を \ctrl{p}で変換の前候補を呼び出せる点は覚えておいた方がよいでしょう。
%% \esc{h} で現在変換中の文節が 平仮名にかわり、\esc{k} でカタカナに変わります。
%%  (※\textbf{\Machine 内では、\ovalbox{Esc} の代わりに\ovalbox{Shift}を使って下さい。}) 

%% また、小さな「っ」や「ゃ」や「ぁ」は、[xtu] や[xya] や [xa] と ``x'' をつけることで出すことができます。
%% 子音に限っては重ねて打つ [ttu] とか[kka] のようにすることで 「っつ」とか「っか」と出したり、
%% [shu] とか [hya] と打つことで「しゅ」とか「ひゃ」と出すことができます。

%日本語を書けるようになったら、ホームディレクトリの下に {\tt .plan}という名前のファイルを
%用意してそこに自分の所属やアピールしたい点を書いておくとよいかも知れません。
%このファイルは後で出て来る(\S \ref{sect: finger})finger というコマンドで表示される情報を
%書いておくためのファイルです。

\section{Gnuplotを使う}
\label{sec:unix:gnuplot}

計算結果をグラフに変換するツールはいろいろあるが、UNIXで最もよく使われているものの一つに{\tt gnuplot}がある。この節では、{\tt gnuplot}の基本的な使い方を解説する。

\subsection{Gnuplotの起動とデータのプロット}

ターミナルで
\begin{commandline2}
\prompt \underline{gnuplot}
\end{commandline2} \noindent
と入力すると、{\tt gnuplot}が起動し、プロンプトが表示される。
\begin{commandline2}
gnuplot>
\end{commandline2} \noindent
終了するには、
\begin{commandline2}
gnuplot> \underline{exit}
\end{commandline2} \noindent
と入力する。また、
\begin{commandline2}
gnuplot> \underline{help}
\end{commandline2} \noindent
あるいは、
\begin{commandline2}
gnuplot> \underline{help {\it command}}
\end{commandline2} \noindent
でコマンドの説明が表示される。

次に、データをプロットしてみよう。Emacsやviなどのエディタを使って、{\tt data.dat}という名前で、中身が
\begin{quote}
 1.0 2.0 \\
 2.0 4.0 \\
 3.0 6.0 \\
 4.0 8.0 \\
 5.0 10.0
\end{quote}
のようなファイルを用意し、
\begin{commandline2}
gnuplot> \underline{plot 'data.dat'}
\end{commandline2} \noindent
と入力するとプロットされる。 データファイルには1行に「横軸の値と縦軸の値」を入れる。グラフの右上にデータセット名(デフォルトではファイル名)を示す「data.dat」が表示される。これは任意の名前あるいは非表示に変更できる。

上の例では、データファイル{\tt data.dat}が置いてあるディレクトリで{\tt gnuplot}を起動している。別ディレクトリにあるデータファイルをプロットするには、絶対パスか相対パスでファイル名を指定するか、
\begin{commandline2}
gnuplot> \underline{cd '{\it directory}'}
\end{commandline2} \noindent
でデータファイルの置いてあるディレクトリに移動した後、プロットすればよい。現在どのディレクトリにいるかを知るには{\tt pwd}コマンド({\bf p}resent {\bf w}orking {\bf d}irectoryの略)を使う。
\begin{commandline2}
gnuplot> \underline{pwd}\\
/Users/...  
\end{commandline2} \noindent

\subsection{スクリプトファイルの読み込み、書き出し}

{\tt gnuplot}は1行ずつコマンドを実行しプロットしていく対話型スタイルが基本であるが、複雑なプロットの場合には、実行したいコマンドをスクリプトファイルの形でにあらかじめ用意しておき、一括して読み込む方が便利である。例えば、Emacsやviなどのエディタを使って、{\tt plot.plt}という名前で、中身が
\begin{quote}
plot 'data.dat'
\end{quote}
のようなファイルを用意し、{\tt gnuplot}の中で
\begin{commandline2}
gnuplot> \underline{load 'plot.plt'}
\end{commandline2} \noindent
と入力すると、上の例と同じプロットが表示される。あるいは、ターミナルで直接
\begin{commandline2}
\prompt \underline{gnuplot plot.plt}
\end{commandline2} \noindent
としてもよい。環境によっては、プロットが一瞬だけ表示されてすぐに消えてしまうが、その場合は、
\begin{commandline2}
\prompt \underline{gnuplot -persist plot.plt}
\end{commandline2} \noindent
とすればよい。

対話形式で作成したプロットをスクリプトファイルに保存することもできる。
\begin{commandline2}
gnuplot> \underline{save 'plot2.plt'}
\end{commandline2} \noindent
以下で説明するx軸やy軸、キャプション、矢印の設定など、その時点での全ての設定が保存される。保存したスクリプトファイルは{\tt load}コマンドで再度読み込むことができる。

\subsection{プロットスタイル}
関数をプロットするには、
\begin{commandline2}
gnuplot> plot sin(x)
\end{commandline2} \noindent
のようにすればよい。次のように関数を定義して使うこともできる。
\begin{commandline2}
gnuplot> \underline{f(x) = sin(x)} \\
gnuplot> \underline{g(x) = A*cos(x)*exp(x)} \\
gnuplot> \underline{A = 10.0} \\
gnuplot> \underline{plot f(x), g(x)}
\end{commandline2} \noindent
関数の値のサンプリングのピッチを変えるには、
\begin{commandline2}
gnuplot> \underline{set sample 10000}
\end{commandline2} \noindent
とする。

一方、データファイル内のデータをプロットするには、引用符内にデータファイル名を指定する。
\begin{commandline2}
gnuplot> plot '{\it filename}'
\end{commandline2} \noindent
{\tt plot}コマンドには様々なオプションが指定できる。以下、代表的なものを挙げる。
\begin{itemize}
\item {\tt index 0:0} \\
  データファイルの内、最初のデータセットを使う(省略可)
\item {\tt using 1:3} \ ({\tt u 1:3}と省略可。{\tt using (\$1):(\$3)}と等価) \\
  データセットの1列目をx座標、3列目をy座標としてプロットする
\item {\tt using 1:(\$2*10)} \\
  データセットの2列目の値を10倍したものを$y$座標としてプロットする  
\item {\tt using 1:(\$2+f(\$1))} \\\
  関数$f(x)$を定義しておき、その関数値をプロットすることもできる
\item {\tt with line} \ ({\tt w l}と省略可) \\
  データを線で結ぶ
\item {\tt with linespoints} \\
  データをシンボルで表示し、さらに線で結ぶ
\item {\tt using 1:2:3 with yerrorbars} \\
  y座標の値にエラーバーを付ける。エラーバーとしてどの列を使うかは{\tt using}オプションで指定する
\item {\tt using 1:2:3 with yerrorlines} \\
  y座標の値にエラーバーを付け、線で結ぶ
\item {\tt title 'hoge'} \ ({\tt ti 'hoge'}と省略可) \\
  図の凡例の文字列を指定する
\item {\tt notitle} \\
  凡例をつけない
\item {\tt linewidth 3} \ ({\tt lw 3}と省略可) \\
  線の幅を3倍にする(論文用の図としては{\tt lw 3}くらいがよい)
\item {\tt linecolor 7} \ ({\tt lc 7}と省略可) \\
  線の色を指定する。青は6、赤は7など。
\item {\tt dashtype 2} \ ({\tt dt 2}と省略可) \\
  2から5まで4種類の破線や点線が選べる
\item {\tt pointtype 2} \ ({\tt pt 2}と省略可) \\
  データ点のシンボルを指定する。1は十字、2はX印、4は四角など
\end{itemize}
これらを応用すると、次のようなことができる。
\begin{commandline2}
gnuplot> \underline{plot 'data.dat' with line linecolor 6, 'data2.dat' linecolor 7}
\end{commandline2} \noindent
では、{\tt data.dat}の点は青線でつながり、{\tt data2.dat}は赤点のみでプロットされる(data2.datも自分で用意すること)。また、点ではなく常につながった線で表示させるには、
\begin{commandline2}
gnuplot> \underline{set style data line}\\
gnuplot> \underline{plot 'data.dat', 'data2.dat'}
\end{commandline2} \noindent
とする。

直前のプロットを再プロットするには、
\begin{commandline2}
gnuplot> \underline{replot}
\end{commandline2} \noindent
とする。

\subsection{三次元プロット}

二次元関数をプロットするには{\tt splot}コマンドを使う。
\begin{commandline2}
gnuplot> \underline{splot x*y}
\end{commandline2} \noindent
メッシュの幅を指定するには、
\begin{commandline2}
gnuplot> \underline{set isosamples 20}
\end{commandline2} \noindent
とする。

データファイルから三次元プロットするには
\begin{commandline2}
gnuplot> \underline{splot '{\it filename}' using 1:2:5}
\end{commandline2} \noindent
のようにする。{\tt using}オプションで、x座標、y座標、関数値の列を指定する。二次元プロットと同様に、エラーバーをつけることも可能である。

\subsection{x軸・y軸の設定}

x軸をlogスケールにするには、
\begin{commandline2}
gnuplot> \underline{set log x}
\end{commandline2} \noindent
x軸をリニアスケールにする(戻す)には、
\begin{commandline2}
gnuplot> \underline{unset log x}
\end{commandline2} \noindent
y軸をlogスケールにするためには、
\begin{commandline2}
gnuplot> \underline{set log y}
\end{commandline2} \noindent
などとする。

x軸にラベルを付けるには、
\begin{commandline2}
gnuplot> \underline{set xlabel 'x axis'}
\end{commandline2} \noindent
x軸のプロット範囲を指定するには、
\begin{commandline2}
gnuplot> \underline{set xrange [-10:10]}
\end{commandline2} \noindent
のようにする。x軸上に長めの目盛り(tic)を5おきに、数値とともに打つには、
\begin{commandline2}
gnuplot> \underline{set xtics 5}
\end{commandline2} \noindent
とする。あるいは、x軸の目盛りを-3から1おきに5までふるには、
\begin{commandline2}
gnuplot> \underline{set xtics -3,1,5}
\end{commandline2} \noindent
とすればよい。x軸の長めの目盛りの間を10分割して、短い目盛りをふるには、
\begin{commandline2}
gnuplot> \underline{set mxtics 10}
\end{commandline2} \noindent
とする。y軸に関しても同様である。

プロット中に$y=0$の軸を引くには、
\begin{commandline2}
gnuplot> \underline{set xzeroaxis}
\end{commandline2} \noindent
とする。

\subsection{表題・凡例・図の形}

グラフそのものに表題を付けるには、
\begin{commandline2}
gnuplot> \underline{set title 'Title of this plot'}
\end{commandline2} \noindent
とする。
レジェンド(凡例)の表示位置は、標準で右上(right top)に表示されるが、位置を変更するには
\begin{commandline2}
gnuplot> \underline{set key left bottom}
\end{commandline2} \noindent
のようにする。レジェンド全体を非表示にするには、
\begin{commandline2}
gnuplot> \underline{unset key}
\end{commandline2} \noindent
とする。

図全体の形は{\tt set size}コマンドで変更できる。図を真四角にするには、
\begin{commandline2}
gnuplot> \underline{set size square}
\end{commandline2} \noindent
図の縦横比を 1:1.5 にするには、
\begin{commandline2}
gnuplot> \underline{set size ratio 1.5}
\end{commandline2} \noindent
とする。

\subsection{矢印・文字列}

図中に矢印や文字列を表示することができる。{\tt (x1,y1)}から{\tt (x2,y2)}に矢印を引くには、
\begin{commandline2}
gnuplot> \underline{set arrow from x1,y1 to x2,y2}
\end{commandline2} \noindent
とする。また、位置{\tt (x,y)}に文字列を表示するには、
\begin{commandline2}
gnuplot> \underline{set label '{\it text}' at x1,y1}
\end{commandline2} \noindent
とすればよい。

\subsection{文字のスタイル}

表題や凡例、軸のラベルなどに使う文字のサイズやフォントは変更することができる。また、ギリシャ文字や上付き・下付き文字を使うこともできる。以下に例を示す。
\begin{itemize}
\item {\tt '\{/=36 energy\}'} \\
  36ポイントの大きさで表示される
\item {\tt '\{/=36 \{/Arial-Italic E\}\}'} \\
  36ポイント斜体で$E$のように表示される
\item {\tt '\{/=36 \{/Symbol D\}\}'} \\
  ギリシャ文字の$\Delta$
\item {\tt '\{/=36 \{/Symbol c\}\^{}\{total\}\_e\}'} \\
  $\chi^{\rm total}_{\rm e}$
\end{itemize}

\subsection{ファイルへの出力}

図をポストスクリプト形式でファイルに出力するには、次のようにする。
\begin{commandline2}
gnuplot> \underline{set term postscript eps color} \\
gnuplot> \underline{set output 'figure.eps'} \\
gnuplot> \underline{load 'figure.plt'}
\end{commandline2} \noindent
プロットの内容がポストスクリプト形式で{\tt figure.eps}に出力される。出力された図は、\LaTeX に取り込むことができる。

なお、これ以降の操作も{\tt figure.eps}に上書きされるので注意が必要である。元の設定に戻すには
\begin{commandline2}
gnuplot> \underline{set output} \\
gnuplot> \underline{set term pop}
\end{commandline2} \noindent
を実行する。

%% %\newpage
%% \section{プログラムの作成と実行}
%% プログラム言語にはさまざまなものがあります。物理では歴史的にFORTRANを使用していましたが、最近、CやC++を使用することが次第に一般的になってきました。したがって、ここではC言語を中心に説明します。もちろん、FORTRANで記述された便利な関数もC言語から呼び出すことができます。

%% \subsection{C言語}
%% \subsubsection {コンパイル}
%% {\tt trial.c} という C のプログラム
%% \footnote{ソースコードといいます。}
%% が用意できたとします。そうしたら、xterm 上で\\
%% \begin{commandline2}
%% \prompt \underline{gcc trial.c}\\
%% \end{commandline2} \noindent
%% のようにすれば、
%% {\tt a.out} というファイルが実行形式のファイルができあがります。
%% {\bf gcc} が C のコンパイラ
%% \footnote{コンパイルとは人間が読めるプログラムを計算機が読める形式に
%% 変換することです。また、コンパイラとして{\tt acc}だけではなく、{\tt cc, gcc}があります。{\tt gcc}が一般的によく使われます。{\bf cc} は古典的な形式の C 言語のソースコードをコンパイルするのに使い{\bf acc} は古典的な形式の C 言語のほかに ANSI 規格に沿った C 言語のソースコードをコンパイルするのにも使います。さらに、 {\bf gcc} は古典的な形式でも ANSI 形式でもコンパイルできます。}
%% です。
%% これを実行するには\\
%% \begin{commandline2}
%% \prompt \underline{./a.out}\\
%% \end{commandline2} \noindent
%% とします
%% \footnote{
%% 教育用計算機センターの標準の設定では、 \underline{./} を必ずつける必要があります。
%% また、カレントディレクトリにできた実行ファイルは、たとえばそれが
%% {\it executable} という名前だとすると、\\
%% \begin{commandline2}
%% \prompt \underline{./{\it executable}}\\
%% \end{commandline2} \noindent
%% のように入力することで実行できます。}
%% 。

%% {\tt a.out} というファイルに出力されるのが嫌なら、{\tt -o} オプションを使って、\\
%% \begin{commandline2}
%% \prompt \underline{gcc -o trial trial.c}\\
%% \end{commandline2} \noindent
%% のように指定します。この例では {\tt trial} というファイルに出力されます。実行するためには、\\
%% \begin{commandline2}
%% \prompt \underline{./trial}\\
%% \end{commandline2} \noindent
%% とします。

%% \subsubsection {分割コンパイル}
%% ソースコードが大きくなり過ぎると、何かと不便です。
%% たとえば、大きなファイルの中から目的の編集箇所を
%% 自分で探さなくてはいけなくなったり、
%% コンパイルに時間がかかったりします。
%% そのようなときはソースコードをいくつかのファイルにわけると
%% よいでしょう。
%% また、ソースコードが大きくなくても、プログラムの意味として
%% まとまりのある部分ごとに 1 つのファイルを作っておくと
%% あとあとのためによいかもしれません。
%% プログラムを複数のファイルに分割して書いた場合、\\
%% \begin{commandline2}
%% \prompt \underline{gcc trial1.c trial2.c trial3.c}\\
%% \end{commandline2} \noindent
%% のように書いてコンパイルします。この場合も -o オプションで出力ファイルを指定することができます。

%% また、いくつかのファイルだけをコンパイル
%% \footnote{
%% 分割コンパイルといいます。}
%% することもできます。\\
%% \begin{commandline2}
%% \prompt \underline{gcc -c trial1.c}\\
%% \end{commandline2} \noindent
%% のようにすれば、{\tt trial1.c} だけがコンパイルされて {\tt trial1.o} がオブジェクトファイル
%% \footnote{
%% コンパイルが途中までできているファイルだと思ってください。
%% }
%% として生成されますし、\\
%% \begin{commandline2}
%% \prompt \underline{gcc -c trial1.c trial2.c trial3.c}\\
%% \end{commandline2} \noindent
%% のようにすれば 3 つのオブジェクトファイル {\tt trial1.o trial2.o trial3.o}
%% が作られます。オブジェクトファイルができたら、\\
%% 前者なら\\
%% \begin{commandline2}
%% \prompt \underline{gcc -o trial trial1.o trial2.f trial3.f}\\
%% \end{commandline2} \noindent
%% のような形で、コンパイルすればよいでしょうし、
%% 後者なら\\
%% \begin{commandline2}
%% \prompt \underline{gcc -o trial trial1.o trial2.o trial3.o}\\
%% \end{commandline2} \noindent
%% のようにすればよいでしょう。
%% 分割コンパイルの最大の利点は、コンパイル時間の短縮です。
%% {\tt trial3.c} だけを変更したのに、\\
%% 3 つのファイル {\tt trial1.c trial2.c trial3.c} をわざわざ
%% コンパイルするのでは時間がかかってしまいます。
%% そこで、オブジェクトファイルを作っておいて、
%% 変更のあったものだけ再コンパイルすればよいのです。つまり、\\
%% \begin{commandline2}
%% \prompt \underline{gcc -c trial3.o}
%% \end{commandline2} \noindent\\
%% \begin{commandline2}
%% \prompt \underline{gcc -o trial trial1.o trial2.o trial3.o}\\
%% \end{commandline2} \noindent
%% とすればいいということです。

%% \subsubsection {リンク}
%% オブジェクトファイルを最終的に {\tt a.out} などの実行形式のファイル
%% にすることをリンクするといいます。
%% オブジェクトファイルの間をうまくとりもって
%% ひとつにまとめ上げる、というような意味です。

%% また、ライブラリ
%% \footnote
%% {みんなが便利なように、だれかがプログラムをした
%% ルーチン群のことです。
%% オブジェクトファイル(をまとめたもの)の形で保管されています。
%% }
%% を使う場合も「ライブラリをリンクする」といいます。

%% 算術ライブラリ\footnote{math.hをソースコードの中でインクルードして、sinやsqrtを使用しているときに使う標準的なライブラリです。}を使っている場合には、\\
%% \begin{commandline2}
%% \prompt \underline{gcc -o trial trial.c -lm}\\
%% \end{commandline2} \noindent
%% のように{\tt -lm}と書いて算術ライブラリもリンク\footnote{NAG ライブラリをリンクする場合は acc を使用して下さい。}して下さい。

%% \subsubsection {C言語からFORTRANの関数や手続きを呼ぶ方法}
%% CERN ライブラリやNAGなどの多くのルーチンがFORTRANで書かれています。これらと同等の機能を持つ関数をCやC++で作るとこともできますが、既に存在するのであればそれを使った方が便利です。そこで、ここではその方法を簡単に紹介します\footnote{詳細は「計算物理の新改訂分の提案」(著 : 渡辺尚貴)のp22以降の「4.FORTRANライブラリとのリンク」を参考にしてください。}。

%% FORTRANの関数や手続きの名前をC言語から呼ぶためには、その名前をすべて小文字にして、最後に\_(下線)を付けなければいけません。また、関数などの引数の型も適切に読み変える必要があります。例えば、
%% \begin{verbatim}
%%       Real*8  CALC(I, X, Y)
%%       Interger*4  I
%%       Real*4      X
%%       Real*8      Y
%% \end{verbatim}
%% という関数が存在するとします。このときCでは次のように使います。
%% \begin{verbatim}
%% extern double clac_(int*, float*, double*);
%% int main(){
%%     int    i =   10;
%%     float  x = 20.0;
%%     double y = 30.0;
%%     double ret;

%%     ret = calc_(&i, &x, &y);

%%     retrun 0;
%% }
%% \end{verbatim}

%% \subsection{C++}
%% オブジェクト指向型プログラミング言語\footnote{他のオブジェクト指向型プログラミング言語としてJAVAがあります。また、Perlのバージョン5からもこの思想が採用されています。}です。C言語と似ていますが、プログラムを設計する考え方が大きく異なっています。

%% \subsubsection {コンパイル}
%% {\tt trial.cc} という C++ のプログラムが用意できたとします。
%% これをコンパイルするためには\\
%% \begin{commandline2}
%% \prompt \underline{g++ trial.cc}
%% \end{commandline2} \noindent\\
%% とします。これで{\tt a.out} という実行形式のファイルができます。分割コンパイルなどはC言語の方法と全く同じです。

%% \subsection{FORTRAN}

%% \subsubsection{コンパイル}
%% {\tt trial.f} という FORTRAN のプログラム
%% が用意できたとします。そうしたら、xterm 上で\\
%% \begin{commandline2}
%% \prompt \underline{g77 trial.f}\\
%% \end{commandline2} \noindent
%% のようにすれば、
%% {\tt a.out} というファイルが実行形式のファイルができあがります。
%% {\bf g77} が FORTRAN のコンパイラです。
%% これを実行するには\\
%% \begin{commandline2}
%% \prompt \underline{./a.out}\\
%% \end{commandline2} \noindent
%% と、します。分割コンパイルはC言語の方法と全く同じです。

%% \subsubsection {リンク}
%% VAX FORTRAN で書かれたプログラムの場合(「計算物理」に載っている多くのプログラム例がそうです。)\\
%% \begin{commandline2}
%% \prompt \underline{g77 -o trial trial.f -lV77}\\
%% \end{commandline2} \noindent
%% のように {\tt -lV77} オプションを追加した方がよい場合があります。

%% NAG ライブラリを使っている場合には、\\
%% \begin{commandline2}
%% \prompt \underline{g77 -o trial trial.f -L\$NAG -lnagd}\\
%% \end{commandline2} \noindent
%% のように{\tt -L\$NAG -lnagd}と書いて NAG ライブラリもリンクして下さい。

%% \subsection {インタープリタ言語}
%% コンパイルをして計算機の言葉にするのではなくて、
%% ソフトウェアがプログラムを直接理解してその内容を実行する仕組みがあります。
%% この「プログラムを直接理解するソフトウェア」のことを
%% インタープリタといい、「プログラム」のことをスクリプトといいます。
%% {\bf sh} 、{\bf csh} 、{\bf bash} 、{\bf awk} 、{\bf perl} などは代表的なインタープリタです。
%% たとえば、{\tt test.pl} という Perl スクリプトを作ったとしましょう。
%% これを実行するには 2 通りの方法があります。\\
%% 1 つ目は
%% \\
%% \begin{commandline2}
%% \prompt \underline{perl test.pl}\\
%% \end{commandline2} \noindent
%% のようにインタープリタ
%% \footnote{
%% {\bf perl}が Perl言語のインタープリタです。}
%% に {\tt test.pl} を読み取らせる方法です。
%% この方法では {\tt test.pl} に読み取り許可がなくてはいけません。\\
%% もう 1 つの方法は
%% \\
%% \begin{commandline2}
%% \prompt \underline{test.pl}\\
%% \end{commandline2} \noindent
%% のように {\tt test.pl} を直接実行
%% \footnote{
%% 実はこっそり Perl インタープリタが起動されていて、
%% それが {\tt test.pl} を読み取ります。なにが起動されるかは、
%% スクリプトの先頭の {\tt \#!} のあとに何を書いたかで決まります。
%% Perl インタープリタを起動する場合は
%% \underline{\tt \#!/usr/local/bin/perl}と書きます。}
%% してしまうやり方です。
%% この方法では {\tt test.pl} に読み取り許可のほかに実行許可もなくてはいけません。

%% %\appendix \label{appendix}

%% \section{トラブルの処理}

%% 以下に例を挙げてみますが、
%% いろいろしても問題が残り、不具合な場合には、電子メール
%% \footnote{
%% 使えないときは直接居室へ。
%% }で、
%% \begin{quote}
%% {\admin}
%% \end{quote}
%% に連絡してください。

%% \subsection{マウスが反応しない}
%% マウスを動かしても、マウスカーソル
%% が動かなくなってしまった場合
%% \footnote{フリーズしたとか凍ったとかいいます。}、
%% 編集中のファイルや実行中のプログラムが止まってしまってもよいのであれば、
%% iMac端末の電源を入れ直しても構いません
%% \footnote{
%% マウスが汚れているだけならば掃除をすると解決するかもしれません。}
%% 。

%% \subsection{ログインできない}
%% {\bf Login incorrect} といわれてしまう場合は、パスワードか
%% ユーザー名が間違っています。\ovalbox{CAPS}によって大文字入力モードに
%% なっていないかどうか確認してください。

%% %ログインパネルは一度消えるけれども、
%% %すぐにまたログインパネルが現われてしまう、という場合は
%% %ディスクの使用量が最大値を超えてしまっていることが
%% %考えられます。このような場合は、友達に頼んで、自分のアカウントにtelnetを
%% %して、不必要なファイルを削除しましょう。それでも、ログインできない場合はTAに尋ねて下さい。

%% \subsection{キーボードの入力を受け付けない}
%% キーボードから打っても反応がない場合等にはなにかの拍子に\ctrl{s}が押された可能性が
%% ありますので、\ctrl{q}を押してみるとよいでしょう
%% \footnote{逆に xterm で出力が流れて行ってしまうときなどには、\ctrl{s}で出力を一時止め、\ctrl{q}で
%% 再開することもできます。}。それでもだめな場合は\S \ref{chap: recover}を参考にしてください。

%% \subsection{日本語が文字化けする}
%% \Machine 以外から持ってきたTeXファイルやCファイルが文字化けする場合は\\
%% \begin{commandline2}
%% \prompt nkf -eO${}^{\mathrm{[オー]}}$ file.tex file\verb/_/new.tex
%% \end{commandline2} \noindent\\
%% などとして、EUC-JPコードへ変換してください。


%% \subsection{a.outが実行できない}
%% プログラミング言語のところでも書いたように、カレントディレクトリに{\tt a.out}がある場合は、\\
%% \begin{commandline2}
%% \prompt \underline{./a.out}
%% \end{commandline2} \noindent\\
%% として実行して下さい。

%% \subsection{コンパイルできない}
%% プログラムの一部が、全角文字(日本語変換)で入力されているため、
%% コンパイルできないことがあります。特に () や｛｝に注意しましょう。

%% \subsection{プログラムが止まらない}
%% xterm 上で、出力が延々と続くときや、計算がいつまで待っても終らない場合には、
%% \ctrl{c}
%% を押して実行を終了
%% \footnote{Emacs の中なら \ctrl{g}を押してみることです。}
%% してください
%% \footnote{
%% \S \ref{chap: recover}も参考にしてください。}。

%% \subsection{その他}
%% トラブルではないけれども、どうしたらよいか分からないようなときや、他の人にも
%% 役にたちそうな質問等は、ニュースを活用して下さい。
